#include <stdio.h>
#include <stdlib.h>

#include "pico/stdlib.h"
#include "hardware/pio.h"
#include "hardware/clocks.h"
#include "ws2812.pio.h"

void main_asm(); 
char input[30];
int current_index = 0;
int level = 1;
int gameStage = 0;
absolute_time_t startTimer;

void add_input(int number) {
    if(gameStage==1)gameStage=2;
    else if (current_index<30&&gameStage==3) {
        if (number == 0) {
            input[current_index] = '.';
            printf(".");
        } else if (number == 1) {
            input[current_index] = '-';
            printf("-");
        } else if (number == 2) {
            input[current_index] = ' ';
        } else if (number == 3){
            input[current_index] = '\0';
        }
        current_index++;
    }
}

void flush_input()
{
    if(gameStage==3)
    {
        gameStage=4;
        input[current_index]='*';
        current_index=0;
        printf("\n");
    }
}

char inputDecode()
{
    if(input[0]=='.'&&input[1]=='-'&&input[2]=='*')return 'A';
    else if(input[0]=='-'&&input[1]=='.'&&input[2]=='.'&&input[3]=='.'&&input[4]=='*')return 'B';
    else if(input[0]=='.'&&input[1]=='*')return 'E';
    else if(input[0]=='.'&&input[1]=='.'&&input[2]=='.'&&input[3]=='.'&&input[4]=='*')return 'H';
    else if(input[0]=='.'&&input[1]=='.'&&input[2]=='*')return 'I';
    else if(input[0]=='.'&&input[1]=='.'&&input[2]=='.'&&input[3]=='*')return 'S';
    return '?';
}

void start_timer(){
    startTimer = get_absolute_time();
}
int end_timer(){
    absolute_time_t end_time = get_absolute_time();
    return (int) absolute_time_diff_us(startTimer, end_time); // find time inbetween, parse int 
}
void levels_increment(){
    if(gameStage==1)
    {
        if(level==4) level=1;
        else level++;
        printf("New level is %i\n",level);
    } 
}


#define IS_RGBW true        // Will use RGBW format
#define NUM_PIXELS 1        // There is 1 WS2812 device in the chain
#define GPIO_PIN 28         // The GPIO pin that the light is connected to 

 int levelOne();
 int levelTwo();
 int levelThree();
 int levelFour();

/**
 * @brief Wrapper function used to call the underlying PIO
 *        function that pushes the 32-bit RGB colour value
 *        out to the LED serially using the PIO0 block. The
 *        function does not return until all of the data has
 *        been written out.
 * 
 * @param pixel_grb The 32-bit colour value generated by urgb_u32()
 */
static inline void put_pixel(uint32_t pixel_grb) {
    pio_sm_put_blocking(pio0, 0, pixel_grb << 8u);
}


/**
 * @brief Function to generate an unsigned 32-bit composit GRB
 *        value by combining the individual 8-bit paramaters for
 *        red, green and blue together in the right order.
 * 
 * @param r     The 8-bit intensity value for the red component
 * @param g     The 8-bit intensity value for the green component
 * @param b     The 8-bit intensity value for the blue component
 * @return uint32_t Returns the resulting composit 32-bit RGB value
 */
static inline uint32_t urgb_u32(uint8_t r, uint8_t g, uint8_t b) {
    return  ((uint32_t) (r) << 8)  |
            ((uint32_t) (g) << 16) |
            (uint32_t) (b);
}


/**
 * @brief Function to generate an unsigned 32-bit composit GRB
 *        value by combining the individual 8-bit paramaters for
 *        red, green and blue together in the right order.
 * 
 * @param r     The 8-bit intensity value for the red component
 * @param g     The 8-bit intensity value for the green component
 * @param b     The 8-bit intensity value for the blue component
 * @return uint32_t Returns the resulting composit 32-bit RGB value
 */
static inline void colour_change(int colour) {
    if(colour==4)  put_pixel(urgb_u32(0x00, 0x00, 0x5F));
    else if(colour==3)  put_pixel(urgb_u32(0x00, 0x5F, 0x00));
    else if(colour==2)  put_pixel(urgb_u32(0x5F, 0x2F, 0x00));
    else if(colour==1)  put_pixel(urgb_u32(0x5F, 0x00, 0x00));
    else if(colour==0)  put_pixel(urgb_u32(0x00, 0x00, 0x00));
}


/**
 * @brief EXAMPLE - WS2812_RGB
 *        Simple example to initialise the NeoPixel RGB LED on
 *        the MAKER-PI-PICO and then flash it in alternating
 *        colours between red, green and blue forever using
 *        one of the RP2040 built-in PIO controllers.
 * 
 * @return int  Application return code (zero for success).
 */
int main() {
 
    main_asm();
    // Initialise all STDIO as we will be using the GPIOs
    stdio_init_all();
    srand(87);
 
    // Initialise the PIO interface with the WS2812 code
    PIO pio = pio0;
    uint offset = pio_add_program(pio, &ws2812_program);
    ws2812_program_init(pio, 0, offset, GPIO_PIN, 800000, IS_RGBW);

    printf("Welcome to group 23's Morse Code Game!\nHow to play?:\nTo play, you simply have to enter the correct morse code sequence for the word (or character) displayed!\nPlease select the difficulty you would like to play on by entering the corresponding morse code character\n");
    // Set the color to red at half intensity
    colour_change(4);


    gameStage=1;
    printf("Current level is %i\n",level);
    while(gameStage==1)
    {
        
    }

    int complete=1;

    switch(level)
    {
        case 1:
            complete=levelOne();
            if(complete==0)break;
        case 2:
            complete=levelTwo();
            if(complete==0)break;
        case 3:
            complete=levelThree();
            if(complete==0)break;
        case 4:
            complete=levelFour();
            break;
        default :
        printf("Error");
        levelOne();
    }

    if(complete==1)printf("\ncongratulations");
    else printf("\nYou lose, good day sir");

    return 0;

}

int levelOne()
{ 
    printf("Beginning with level one");
    int lives=3;
    int correctInARow=0;
    char characters[36]={"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"};
    while((correctInARow<5)&&(lives>0))
    {
        colour_change(lives);

        uint32_t random=to_ms_since_boot(get_absolute_time());
        random%=37;
        printf("\n%c\n",characters[random]);

        gameStage=3;
        while(gameStage==3)
        {   
            int re=4;
            printf("",re);
        }

        char inputChar=inputDecode();

        if(inputChar==characters[random])
        {
            printf("correct!\n");
            correctInARow++;
            if(lives<3)lives++;
        }
        else
        {
            printf("Incorrect input!\n");
            correctInARow=0;
            lives--;
        }
    }   
    if(lives==0)return 0;
    return 1; 
}

int levelTwo()
{ 
    int lives=3;
    int correctInARow=0;
    char characters[36]={"abcdefghijklmnopqrstuvwxyz0123456789"};
    while((correctInARow<5)&&(lives>0))
    {
        colour_change(lives);

        int r=rand();
        r%=37;
        printf("\n%c\n",characters[r]);

        int correctTest=rand();
        correctTest%=1;
    
        if(correctTest==0)
        {
            printf("correct!\n");
            correctInARow++;
            if(lives<3)lives++;
        }
        else
        {
            printf("Incorrect input!\n");
            correctInARow=0;
            lives--;
        }
    }    
    if(lives==0)return 0;
    return 1;
}

int levelThree()
{ 
    int lives=3;
    int correctInARow=0;
    char words[7][7]={"daily","mount","fresh","quite","zebra","young","extra"};
    while((correctInARow<5)&&(lives>0))
    {
        colour_change(lives);

        int r=rand();
        r%=7;
        printf("\n%s\n",words+r);

        int correctTest=rand();
        correctTest%=2;
    
        if(correctTest==1)
        {
            printf("correct!\n");
            correctInARow++;
            if(lives<3)lives++;
        }
        else
        {
            printf("Incorrect input!\n");
            correctInARow=0;
            lives--;
        }
    }    
    if(lives==0)return 0;
    return 1;
}

int levelFour()
{ 
    int lives=3;
    int correctInARow=0;
    char words[7][7]={"daily","mount","fresh","quite","zebra","young","extra"};
    while((correctInARow<5)&&(lives>0))
    {
        colour_change(lives);

        int r=rand();
        r%=7;
        printf("\n%s\n",words+r);

        int correctTest=rand();
        correctTest%=2;
    
        if(correctTest==1)
        {
            printf("correct!\n");
            correctInARow++;
            if(lives<3)lives++;
        }
        else
        {
            printf("Incorrect input!\n");
            correctInARow=0;
            lives--;
        }
    }    
    if(lives==0)return 0;
    return 1;
}

// Initialise a GPIO pin
void asm_gpio_init(uint pin) {
    gpio_init(pin);
}

// Set direction of a GPIO pin
void asm_gpio_set_dir(uint pin, bool out) {
    gpio_set_dir(pin, out);
}

// Get the value of a GPIO pin
bool asm_gpio_get(uint pin) {
    return gpio_get(pin);
}

// Set the value of a GPIO pin 
void asm_gpio_put(uint pin, bool value) {
    gpio_put(pin, value);
}

// Enable falling-edge interrupt 
void asm_gpio_set_irq_fall(uint pin) {
    gpio_set_irq_enabled(pin, GPIO_IRQ_EDGE_FALL, true);
}

// Enable rising-edge interrupt
void asm_gpio_set_irq_rise(uint pin) {
    gpio_set_irq_enabled(pin, GPIO_IRQ_EDGE_RISE, true);
}
